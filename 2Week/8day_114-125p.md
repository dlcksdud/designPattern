# 8일차

헤드퍼스트 디자인패턴 [화요일] 

114-125pg

# 요약

**CHAPTER 03. 객체 꾸미기 (feat. 데코레이터 패턴)**

상속을 남용하는 사례 → 객체 작성 : 실행 중에 클래스를 데코레이션하는 방법 배우기  

[스타바즈]

처음 스타바즈의 코드는 클래스 관련 문제에서

1. 달라지는 부분과, 달라지지 않는 부분 분리하기
2. 구현보다는 인터페이스에 맞춰서 프로그래밍한다. 의 두 가지를 지키고 있지 않다.  

상속을 사용한다고 해서 무조건 유연하거나 관리하기 쉬운 디자인이 아니다.

구성과 위임으로 실행 중에 행동을 ‘상속’하는 방법이 있다.  

[코드 관리에 구성이 미치는 영향]

객체를 동적으로 구성하면 기존 코드를 고치는 대신 새로운 코드를 만들어서 기능을 추가 할 수 있다.  

[디자인 원칙 : OCP: Open-Closed Principle]

클래스는 확장에는 열려 있어야 하지만, 변경에는 닫혀 있어야 한다.

목표: 기존 코드를 건드리지 않고 확장으로 새로운 행동 추가하기  

[데코레이터 패턴 살펴보기]

ex) 특정음료에서 시작해서 첨가물로 그 음료를 장식(decorate) 한다.  

[주문 시스템에 데코레이터 패턴 적용하기]

- 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같다.
- 한 객체를 여러개의 데코레이터로 감쌀 수 있다.
- 데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 가지고 있기에 원래 객체(싸여있는 객체)가 들어갈 자리에 데코레이터 객체를 넣어도 상관 없다.
- 객체는 언제든지 감쌀 수 있다.  

[데코레이터 패턴 정의]

객체에 추가 요소를 동적으로 더할 수 있습니다. 

데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수있습니다.  

# 발췌

<aside>
💡 구성으로 객체의 행동을 확장하면 실행 중에 동적으로 행동을 설정할 수 있습니다.

</aside>
                                                                                                 
<aside>
💡 데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 일 말고도 추가 작업을 수행할 수 있습니다.

</aside>

# 메모

- 코드는 밤의 연꽃처럼 변경에는 닫혀 있고, 아침의 연꽃처럼 확장에는 활짝 열려 있어야 한다.  
- 코드에서 확장해야 할 부분을 선택할 때는 세심한 주의를 기울여야 한다. 무조건 OCP를 적용한다면 괜히 쓸데없는 일을 하며 시간을 낭비할 수 있으며, 필요이상으로 복잡하고 이해하기 힘든 코드를 만들게 되는 부작용이 발생할 수 있다.  

# 숙제

117p 각 클래스에 들어갈 cost() 메소드 코드 작성하기. 수도코드 형태도 가능함  

```java
public class Beverage {
	public double cost() {
			this.cost = cost..? //
	}
}

public class DarkRoast extends Beverage {
	public DartRoast() {
		description = "최고의 다크 로스트 커피";
	}
	
	@Override
	public double cost() {
			// 다크 로스트 커피는 3,000원
			// 모카휘핑크림 더할 것임..
	}
}
```