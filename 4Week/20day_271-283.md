# 20일차

헤드퍼스트 디자인패턴 [4주차_화요일] 

272-283pg  

# 요약

**CHAPTER 07. 적응시키기 (feat. 어댑터 패턴과 퍼사드 패턴)**

- 실제와 다른 인터페이스를 가진 것처럼 보이도록 객체를 감싸면, 특정 인터페이스가 필요한 디자인을 다른 인터페이스를 구현하는 클래스에 적응시킬 수 있다.
- 객체를 감싸서 인터페이스 단순화하기  

[객체지향 어댑터]

- 어떤 인터페이스를 클라이언트에서 요구하는 형태로 적응시키는 역할
- 기존 시스템 =/= 업체에서 제공한 클래스
- 기존시스템 -어댑터-업체에서 제공한 클래스  

[Duck 객체가 모자라서 Turkey  객체를 대신 사용해야 함]

- TurkeyAdaptor 클래스 만들기.
- Duck turkeyAdaptor = new TurkeyAdapter(turkey);
    - 칠면조 객체를 칠면조어댑터로 감싸서 오리 객체처럼 보이도록 한다.
- testDuck(turkeyAdaptor);
    - 오리 대신 칠면조 넣어봄  

[ 어댑터의 역할 ]

- 클라이언트 : 타깃 인터페이스에 맞게 구현되어 있다.
- 어댑터 : 타깃 인터페이스를 구현하며, 어댑티(adaptee) 인스턴스가 들어있다.
- 클라이언트 -request()→ 어댑터 -translatedRequest()→ 어댑티
- 클라이언트와 어댑티는 서로 분리되어 있어서 서로를 전혀 모른다.  

[어댑터 패턴]

- 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환합니다. 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있게 도와준다.
- 객체지향 원칙 반영 : 어댑티를 새로 바뀐 인터페이스로 감쌀 때는 객체 구성(composition)을 사용한다. → 어댑티의 모든 서브 클래스에 어댑터를 쓸 수 있음.  

[객체 어댑터와 클래스 어댑터]

- 클래스 어댑터 패턴을 쓰려면 다중 상속이 필요한데 자바에서는 다중상속이 불가능함.
- 클래스 어댑터는 타깃과 어댑티 모두 서브클래스로 만들어서 사용하고,
- 객체 어댑터는 구성으로 어댑티에 요청을 전달한다.  

# 발췌

<aside>
💡 어댑터 패턴 : 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환합니다. 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있게 도와준다.  

</aside>